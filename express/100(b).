Start off with 
npm init -y

create  server.js and make it as main

npm i express ejs express-ejs-layouts//templatating lang and creates layouts for all the html files


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Express:

What it is: A fast, unopinionated, and minimal web framework for Node.js.
Why it's used: Express simplifies building web applications and APIs by providing a robust set of features for routing, middleware management, 
handling HTTP requests, and more.


EJS (Embedded JavaScript):

What it is: A templating engine that allows you to generate HTML markup with JavaScript.
Why it's used: EJS allows you to embed JavaScript logic (like loops or conditionals) within your HTML, making it useful for rendering dynamic
content on the server side.

express-ejs-layouts:

What it is: A middleware package for Express that helps manage layouts in EJS views.
Why it's used: It simplifies the use of layouts in EJS templates, allowing you to define a common layout (like a header and footer) and 
dynamically insert page-specific content into that layout

example covering all the above three concepts:


1. Setting up Express:

First, install the required packages:

npm init -y
npm i express ejs express-ejs-layouts

2. Basic Example of Each Component:

a) creating express app

//app.js

const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(port, () => {
  console.log(`App running at http://localhost:${port}`);
});

Run your app using node app.js, 
then visit http://localhost:3000 in your browser to see "Hello, World!".

b) EJS Example:

To use EJS templating, set up your app to use EJS as the view engine.
fFirst, tell Express to use EJS for rendering:

app.set('view engine', 'ejs');

Create a folder called views and inside it, create a file index.ejs:

<!DOCTYPE html>
<html>
<head>
  <title>My EJS Page</title>
</head>
<body>
  <h1>Welcome, <%= name %>!</h1>
</body>
</html>


Update your route to render the EJS file:

app.get('/', (req, res) => {
  res.render('index', { name: 'Pooja' });
});

When you visit http://localhost:3000, you'll see "Welcome, Pooja!" displayed in the browser.

c) express-ejs-layouts Example:

Now, to use layouts with express-ejs-layouts:

Tell Express to use the express-ejs-layouts middleware:

const expressLayouts = require('express-ejs-layouts');
app.use(expressLayouts);

Create a file views/layout.ejs, which will be your main layout template:


<!DOCTYPE html>
<html>
<head>
  <title>My Website</title>
</head>
<body>
  <header>
    <h1>Website Header</h1>
  </header>

  <main>
    <%- body %> <!-- This will insert the content from the child templates -->
  </main>

  <footer>
    <p>Website Footer</p>
  </footer>
</body>
</html>

Modify the index.ejs file (inside the views folder) to use this layout automatically:

<h1>Welcome, <%= name %>!</h1>
<p>This content is rendered inside the layout template.</p>

Your app should now serve the index.ejs content inside the layout. Every view you render will automatically include the layout with the header and footer.

Complete app.js:

const express = require('express');
const expressLayouts = require('express-ejs-layouts');
const app = express();
const port = 3000;


//you donâ€™t need to explicitly require('ejs') in your code because Express automatically requires it behind the scenes when you set 
'ejs' as the view engine. Express is smart enough to load the EJS module as long as it's installed in your project.

app.set('view engine', 'ejs'); // Set EJS as the templating engine and enable layouts
app.use(expressLayouts);

// Basic route
app.get('/', (req, res) => {
  res.render('index', { name: 'Pooja' });
});

app.listen(port, () => {
  console.log(`App running at http://localhost:${port}`);
});

Summary:
Express handles routing.
EJS renders dynamic content in HTML.
express-ejs-layouts manages common layouts like headers/footers across different views.




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


it adss them packages in the dependencies section.

now isntall development dependencies.

npm i --save-dev nodemon //refreshes our server evertime we make a change.


we can run a scripts:

"start": "node server.js"  //for production
"devStart": nodemon server.js

in server.js

const express = require('express')
const app = express()
const expressLayouts = require ('express-ejs-layouts')

app.set('view-engine',ejs)
app.set('views', __dirname + '/views') //where views is coming from

#create views folder.

app.set('layout','layouts/layout') #basically have commong header and footer in the common file.
app.use(expressLayouts) #use expressLayouts. 
app.use(express.static('public')) #where we are going to have stylesheet, iamges, js

#create public folder

app.listen(process.env.PORT || 3000)

npm run devStart

nwo lets create routes folder which is also called contoller

and then create models. 

index.js inside the routes folder


const express = require('express')
cosnt router = express.Router()


router.get('/', (req,res)=>{ 
 res.send('hello world')
})

module.exports = router

we need to to improt this router in the server.


//server.js

const indexRouter = require(./routes/index)

app.use('/', indexRouter)

in the views
create layouts/layouts.ejs


boiler plate html.
<! and enter

inside the <body> before and after every single page.

<body>
Before
<br>
<%- body %>
<br>
After
</body>

view => index.ejs

Middle 

now 
index.js

instead of send we render the tmepalte.

router.get('/', (req,res)=>{ 
 res.render(index.ejs)
})


before
middle
after


lets integrate the model.

install the mongo db

npm i mongoose //integrate mongodb

const mongoose = require('mongoose')
mongoose.connect(process.env.DATABASE_URL, {useNewUrlParser:true})
const db = mongoose.connection
db.on('error', error => console.error(error))
db.once('open', () => console.error('connected to mongoose'))


''''

mongoose.connect(): This function establishes a connection to your MongoDB database.

process.env.DATABASE_URL: This accesses the DATABASE_URL environment variable from your .env file, which should contain the connection
string for your MongoDB database (e.g., mongodb://username:password@host:port/database).

since we are running it locally in our case, we just gotta put DATABASE_URL = mongodb://localhost/NAMEOFYOURDATABSE in the env file and

localhost:27017/ 27017 is the default port.

mongoose.connection: This creates a reference to the connection object, which can be used to listen for certain events 
(such as errors or successful connections).


db.on('error', ..) This sets up an event listener that listens for an 'error' event on the connection object.
If the connection fails, the error is logged to the console using console.error(error).

db.once('open', ...): This listens for the 'open' event, which is triggered when the connection to MongoDB is successfully established.
Once the connection is open, it logs "connected to mongoose" to the console.

''''



install dot env whic helps in configuring the env vari in the prject.

npm i --save-dev dotenv

create .env and put diff varibles

DATABASE_URL = mongodb://localhost/deerbooks

if (process.env.NODE_ENV !== 'production'){
  require('dotenv').parse()
}


.gitignore

.env
node_modules



.env

DATABASE_URL = mongodb://localhost/bookbro

______________________________
Create an Account on Heroku:

Go to the Heroku website and sign up for a free account.
After logging in, create a new app:
App Name: Enter the_app_name.

Click on Create App.
Log in to Heroku via Command Line we have an option to install it from the UI and after installing it, open your terminal or command prompt and run:

heroku login
Enter your email and password when prompted.

Deploy Your App:

In your terminal, navigate to your project directory and run:

git push heroku master

This command pushes your code to Heroku, deploying your application.

Set Up Environment Variables on Heroku:

Go to your Heroku app dashboard.
Navigate to Settings.
Under Config Vars, add a new variable:
Key: DATABASE_URI
Value: (this will be your MongoDB connection string from MongoDB Atlas).

Create a MongoDB Atlas Cluster:

Go to MongoDB Atlas.
Sign in or create an account.
Click on Build a Cluster:
Choose AWS and select the region closest to your target audience.
Click on Create Cluster.
Get Your MongoDB Connection String:

Once your cluster is created, go to the Database Deployments section.
Click on Connect for your cluster.
Choose Connect your application.

Copy the connection string provided (it will look something like this):

mongodb+srv://<username>:<password>@cluster0.mongodb.net/<dbname>?retryWrites=true&w=majority

Create a MongoDB User:

In the MongoDB Atlas dashboard, go to Database Access.
Click on Add New Database User:
Set a username and password for the user.
Ensure the user has the appropriate permissions.

Update Connection String:
Replace <username> and <password> in your connection string with the credentials you just created.
Replace <dbname> with the name of the database you want to use (you can create it later, or MongoDB will create it when you first insert data).

Paste the Connection String in Heroku:

Go back to Heroku's Config Vars.
Set the value of DATABASE_URI to the updated MongoDB connection string.

_____________________________________________________________________




In the mongodb

use newDB
switched to db newDB
db.items.insert({name:"name"})
DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('66ec70a21cd646fb0d9bbc72')
  }
}
db.items.insertOne({name:"name"})
{
  acknowledged: true,
  insertedId: ObjectId('66ec70b31cd646fb0d9bbc73')
}
db.items.find()
{
  _id: ObjectId('66ec70a21cd646fb0d9bbc72'),
  name: 'name'
}
{
  _id: ObjectId('66ec70b31cd646fb0d9bbc73'),
  name: 'name'
}

SHOW DATABASES;


_____________________________________________




create a new file author.js in routes folder.

create authors, search authors



const express = require('express')
const router = express.Router()


//all authors route
router.get('/',(req,res)=>{
  res.render('authors/index')
})

router.get('/new',(req,res)=>{
  res.render('authors/new')
})

//create author route
router.post('/', (req,res)=>{
res.send('create')

})

module.exports = router



view -> create folder -> authors -> index.ejs and new.ejs


inside server.js


const authorRouter = require('/router/authors')


app.use('/authors',authorRouter)  // authors/new




and now create partials -> it allows to break into smaller files. so we dont have to duplicate the code.



we will have to require body patse lib to read the input data sent in the url




