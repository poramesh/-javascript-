Start off with 
npm init -y

create  server.js and make it as main

npm i express ejs express-ejs-layouts//templatating lang and creates layouts for all the html files



''''

Express:

What it is: A fast, unopinionated, and minimal web framework for Node.js.
Why it's used: Express simplifies building web applications and APIs by providing a robust set of features for routing, middleware management, 
handling HTTP requests, and more.


EJS (Embedded JavaScript):

What it is: A templating engine that allows you to generate HTML markup with JavaScript.
Why it's used: EJS allows you to embed JavaScript logic (like loops or conditionals) within your HTML, making it useful for rendering dynamic
content on the server side.

express-ejs-layouts:

What it is: A middleware package for Express that helps manage layouts in EJS views.
Why it's used: It simplifies the use of layouts in EJS templates, allowing you to define a common layout (like a header and footer) and 
dynamically insert page-specific content into that layout

''''

it adss them packages in the dependencies section.

now isntall development dependencies.

npm i --save-dev nodemon //refreshes our server evertime we make a change.


we can run a scripts:

"start": "node server.js"  //for production
"devStart": nodemon server.js

in server.js

const express = require('express')
const app = express()
const expressLayouts = require ('express-ejs-layouts')

app.set('view-engine',ejs)
app.set('views', __dirname + '/views') //where views is coming from

#create views folder.

app.set('layout','layouts/layout') #basically have commong header and footer in the common file.
app.use(expressLayouts) #use expressLayouts. 
app.use(express.static('public')) #where we are going to have stylesheet, iamges, js

#create public 

app.listen(process.env.PORT || 3000)

npm run devStart

nwo lets create routes folder which is also called contoller

and then create models. 

index.js inside the routes folder


const express = require('express')
cosnt router = express.Router()


router.get('/', (req,res)=>{ 
 res.send('hello world')
})

module.exports = router

we need to to improt this router in the server.


//server.js

const indexRouter = require(./routes/index)

app.use('/', indexRouter)

in the views
create layouts/layouts.ejs


boiler plate html.
<! and enter

inside the <body> before and after every single page.

<body>
Before
<br>
<%- body %>
<br>
After
</body>

view => index.ejs

Middle 

now 
index.js

instead of send we render the tmepalte.

router.get('/', (req,res)=>{ 
 res.render(index.ejs)
})


before
middle
after


lets integrate the model.

installign the mongo db

install the lib

npm i mongoose //integrate mongodb

const mongoose = require('mongoose')
mongoose.connect(process.env.DATABASE_URL, {useNewUrlParser:true})
const db = mongoose.connection
db.on('error', error => console.error(error))
db.once('open', () => console.error('connected to mongoose'))


''''

mongoose.connect(): This function establishes a connection to your MongoDB database.

process.env.DATABASE_URL: This accesses the DATABASE_URL environment variable from your .env file, which should contain the connection
string for your MongoDB database (e.g., mongodb://username:password@host:port/database).

mongoose.connection: This creates a reference to the connection object, which can be used to listen for certain events 
(such as errors or successful connections).


db.on('error', ..) This sets up an event listener that listens for an 'error' event on the connection object.
If the connection fails, the error is logged to the console using console.error(error).

db.once('open', ...): This listens for the 'open' event, which is triggered when the connection to MongoDB is successfully established.
Once the connection is open, it logs "connected to mongoose" to the console.

''''



install dot env whic helps in configuring the env vari in the prject.

npm i --save-dev dotenv

create .env and put diff varibles

 

if (process.env.NODE_ENV !== 'production'){
  require('dotenv').parse()
}


.gitignore

.env
node_modules



.env

DATABASE_URL = mongodb://localhost/bookbro

______________________________
create an account on heroku


app name : mybrarry
create app

heroku login


email:
password:


git push heroku master


set up the environemny on heorku

settings -> 

config vars

database_uri

mongodb atlaS

build cluster: aws -> countty closest.
default.
create cluster.

pull the url, and put it in the heroku.


create a mongoDB user

username: passwrd:

conenct to application.

connecgion stirng and paste it in uri

_____________________________________________________________________




In the mongodb

use newDB
switched to db newDB
db.items.insert({name:"name"})
DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('66ec70a21cd646fb0d9bbc72')
  }
}
db.items.insertOne({name:"name"})
{
  acknowledged: true,
  insertedId: ObjectId('66ec70b31cd646fb0d9bbc73')
}
db.items.find()
{
  _id: ObjectId('66ec70a21cd646fb0d9bbc72'),
  name: 'name'
}
{
  _id: ObjectId('66ec70b31cd646fb0d9bbc73'),
  name: 'name'
}
SHOW DATABASES;


_____________________________________________




create a new file author.js in routes folder.

create authors, search authors



const express = require('express')
const router = express.Router()


//all authors route
router.get('/',(req,res)=>{
  res.render('authors/index')
})

router.get('/new',(req,res)=>{
  res.render('authors/new')
})

//create author route
router.post('/', (req,res)=>{
res.send('create')

})

module.exports = router



view -> create folder -> authors -> index.ejs and new.ejs


inside server.js


const authorRouter = require('/router/authors')


app.use('/authors',authorRouter)  // authors/new




and now create partials -> it allows to break into smaller files. so we dont have to duplicate the code.



we will have to require body patse lib to read the input data sent in the url




