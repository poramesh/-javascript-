Prerequisites

We'll need the following to get started:

Expo Go installed on a physical device
Node.js (LTS version) installed
VS Code or any other preferred code editor or IDE installed
A macOS, Linux, or Windows (PowerShell and WSL2) with a terminal window open


1. open vs code and run this on terminal:

npx create-expo-app@latest StickerSmash && cd StickerSmash //creaate a project named StickerSmash

cd StickerSmash  //navigate to the project directory


This command will create a new project directory named StickerSmash, using the default template. This template has essential boilerplate code 
and libraries needed to build our app, including Expo Router. We'll continue to add more libraries throughout this tutorial as needed.

Benefits of using the default template
Creates a new React Native project with expo package installed
Includes recommended tools such as Expo CLI
Includes a tab navigator from Expo Router to provide a basic navigation system
Automatically configured to run a project on multiple platforms: Android, iOS, and web
TypeScript configured by default



2. download the assets frm this offical documentation https://docs.expo.dev/tutorial/create-your-first-app/




3. Run reset-project script

npm run reset-project

What does the reset-project script do?
reset-project script resets the app directory structure in a project and copies the previous boilerplate files from the project's root directory to another 
sub-directory called app-example. We can delete it since it is not part of our main app's structure.



4. Run the app on mobile and web

npx expo start


After running the above command:

The development server will start, and you'll see a QR code inside the terminal window.
Scan that QR code to open the app on the device. On Android, use the Expo Go > Scan QR code option. On iOS, use the default camera app.
To run the web app, press w in the terminal. It will open the web app in the default web browser.




5. Edit the index screen

currently index.tsx got this

import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}


and _layout.tsx

import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}



The app/index.tsx file defines the text displayed on the app's screen. It is the entry point of our app and executes when the development server starts.
It uses core React Native components such as <View> and <Text> to display background and text.

Styles applied to these components use JavaScript objects rather than CSS, which is used on web. However, a lot of the properties will look familiar 
if you've previously used CSS on web. Most React Native components accept a style prop that accepts a JavaScript object as its value. 


Let's modify app/index.tsx screen:

1. Import StyleSheet from react-native and create a styles object to define our custom styles.
2. Add a styles.container.backgroundColor property to <View> with the value of #25292e. This changes the background color.
3. Replace the default value of <Text> with "Home screen".
4. Add a styles.text.color property to <Text> with the value of #fff (white) to change the text color.


app/index.tsx

import { Text, View,  StyleSheet } from 'react-native';

export default function Index() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Home screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
    justifyContent: 'center',
  },
  text: {
    color: '#fff',
  },
});





Key Features of Stack in expo-router:

Screen Management:
The Stack allows you to define and navigate between multiple screens.
Each new screen is added on top of the stack, and you can go back to the previous screen by popping the current one.

Routing Integration:
It integrates with the expo-router routing system, which uses a file-based approach. 
For example:
Files in the pages/ directory are automatically mapped to screens.
A file named index.js or index.tsx becomes the root screen.
Other files like [id].js define dynamic routes.

Customizable Navigation:
You can customize the header, animations, and behavior for each screen in the stack.
Example: Setting screen-specific options like titles or hiding the header.
Example:
Hereâ€™s how the Stack works with expo-router:

// app/layout.js
import { Stack } from "expo-router";

export default function RootLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: true, // Show headers for all screens
      }}
    />
  );
}

// app/index.js
export default function HomeScreen() {
  return <Text>Home Screen</Text>;
}

// app/details.js
export default function DetailsScreen() {
  return <Text>Details Screen</Text>;
}



How It Works???

File-Based Routing:
app/index.js maps to the home screen.
app/details.js maps to another screen.

Navigation:
When you navigate from the home screen to the details screen, the details screen is pushed onto the stack.
Going back will pop the details screen off the stack.



a lil about metro bundler:

Metro Bundler is a JavaScript bundler designed specifically for React Native projects.
It packages your code (and its dependencies) into a format that can be run in the app, whether it's for Android, iOS, or the web.

